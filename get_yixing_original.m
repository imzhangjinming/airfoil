function zhi = get_yixing_original(wenjianming)
%这个是整合的生成翼型的东西，生成三维的点列了。然后一整圈的那种。
    [circleRadius,circleCenterCoordinates,tangencyPointsS1,tangencyPointsS2,KZRetc] ...
    = duqu_fuke(wenjianming);
    %安排一下各个面的坐标。
    xyzSP1 = [KZRetc(:,2).*sin(KZRetc(:,3)),...
        KZRetc(:,2).*cos(KZRetc(:,3)),...
        KZRetc(:,1)] ; 
    xyzSP2 = [KZRetc(:,2).*sin(KZRetc(:,4)),...
        KZRetc(:,2).*cos(KZRetc(:,4)),...
        KZRetc(:,1)] ; 
    %安排一下所谓前后缘圆的圆心
    xyzC3L = [circleCenterCoordinates(1,1)*sin(circleCenterCoordinates(4,1)),...
        circleCenterCoordinates(1,1)*cos(circleCenterCoordinates(4,1)),...
        circleCenterCoordinates(2,1)] ;  
    xyzC3T = [circleCenterCoordinates(1,2)*sin(circleCenterCoordinates(4,2)),...
        circleCenterCoordinates(1,2)*cos(circleCenterCoordinates(4,2)),...
        circleCenterCoordinates(2,2)] ;  
    
    %安排一下所谓切点的位置。
    xyzTPL1 = [circleCenterCoordinates(1,1)*sin(tangencyPointsS1(2,1)),...
        circleCenterCoordinates(1,1)*cos(tangencyPointsS1(2,1)),...
        tangencyPointsS1(1,1)] ; 
    xyzTPL2 = [circleCenterCoordinates(1,1)*sin(tangencyPointsS2(2,1)),...
        circleCenterCoordinates(1,1)*cos(tangencyPointsS2(2,1)),...
        tangencyPointsS2(1,1)] ; 
    xyzTPT1 = [circleCenterCoordinates(1,2)*sin(tangencyPointsS1(2,2)),...
        circleCenterCoordinates(1,2)*cos(tangencyPointsS1(2,2)),...
        tangencyPointsS1(1,2)] ; 
    xyzTPT2 = [circleCenterCoordinates(1,2)*sin(tangencyPointsS2(2,2)),...
        circleCenterCoordinates(1,2)*cos(tangencyPointsS2(2,2)),...
        tangencyPointsS2(1,2)] ;
    xiuzhengTPT = xyzC3T - (xyzTPT1+xyzTPT2)/2 ; 
    xyzTPT1 = xyzTPT1 + xiuzhengTPT ; 
    xyzTPT2 = xyzTPT2 + xiuzhengTPT ; 
    
    xiuzhengTPL = xyzC3L - (xyzTPL1+xyzTPL2)/2 ; 
    xyzTPL1 = xyzTPL1 + xiuzhengTPL ; 
    xyzTPL2 = xyzTPL2 + xiuzhengTPL ; 
    %然后就是安排一手前后缘的生成了，讲道理这就离谱这个圆的前后缘
%     RL = norm(xyzTPL1-xyzTPL2 , 2)/2 ; 
%  %这个求出来的半径和下面那个似乎是一致的。但是切点并不在圆上也不相切，就离谱。
%     RL = circleRadius(1,1) ; 
    %用专业的向量运算来完成前后缘的生成吧。
    xyzYuanL = get_circleEdge(xyzC3L,xyzTPL1,xyzTPL2,circleRadius(1,1)) ; 
    xyzYuanT = get_circleEdge(xyzC3T,xyzTPT2,xyzTPT1,circleRadius(1,2)) ;
    
    %然后安排一手整理，就直接可以输出二维叶形了嗷。
    flagSP1 = (xyzSP1(:,3)>xyzTPL1(3))&(xyzSP1(:,3)<xyzTPT1(3)) ; 
    flagSP2 = (xyzSP2(:,3)>xyzTPL2(3))&(xyzSP2(:,3)<xyzTPT2(3)) ; 
    
    yixing = [xyzYuanL ;...
        xyzSP1(flagSP1,:) ; ...
        xyzYuanT ; ...
        flipud(xyzSP2(flagSP2,:)) ;...
        xyzYuanL(1,:)
        ] ; 
%     huatu ; 
    zhi = yixing ;
end